
#define NOMINMAX
#define MAXENTRIES 600
#include <windows.h>
#include <vector>
#include <fstream>
#include <string>
#include <iostream>
#include <cmath>
#include <algorithm>
#include <stack>
#include <list>
#include <climits>
using namespace std;





#define ID_FILE_EXIT 1
#define ID_COLOR_RED 2
#define ID_COLOR_GREEN 3
#define ID_COLOR_BLUE 4
#define ID_SCREEN_CLEAR 5
#define ID_BACKGROUND_WHITE 6
#define ID_SAVE 7
#define ID_LOAD 8

#define ID_CIRCLE_DIRECT 101
#define ID_CIRCLE_POLAR 102
#define ID_CIRCLE_ITERATIVE_POLAR 103
#define ID_CIRCLE_MIDPOINT 104
#define ID_CIRCLE_MODIFIED_MIDPOINT 105
#define ID_CIRCLE_FILL_LINES 106
#define ID_CIRCLE_FILL_CIRCLES 107
#define ID_QUARTER_1 201
#define ID_QUARTER_2 202
#define ID_QUARTER_3 203
#define ID_QUARTER_4 204

#define ID_BEZIER_CURVE 300
#define ID_HERMITE_CURVE 301
#define ID_SQUARE_HERMITE 302
#define ID_RECTANGLE_BEZIER 303
#define ID_POLYGON_CONVEX 304
#define ID_POLYGON_NONCONVEX 305
#define ID_FLOOD_RECURSIVE 306
#define ID_FLOOD_NON_RECURSIVE 307
#define ID_EMPTY_SQUARE 308


#define ID_LINE_BRESENHAM 100
#define ID_LINE_DDA 205
#define ID_LINE_PARAMETRIC 206

#define ID_POINT 207

#define ID_CLIP_NONE    4001
#define ID_CLIP_RECTANGLE  4002
#define ID_CLIP_SQUARE     4003
#define ID_CLIP_POLYGON     4005

#define ID_ELLIPSE_DIRECT    5001
#define ID_ELLIPSE_POLAR  5002
#define ID_ELLIPSE_MIDPOINT     5003
#define ID_SPLINES_CURVE     5004
#define ID_DROW_SPLINES    5005


void ShowConsole() {
    AllocConsole();

    FILE* fOut;
    FILE* fIn;

    freopen_s(&fOut, "CONOUT$", "w", stdout);
    freopen_s(&fIn, "CONIN$", "r", stdin);
}



// Structures for shapes

int Round(double m) {
    return (int)(m + 0.5);
}


struct vector2 {  // i will enter points like p(1,2) so i want to take x=1,y=2
    double x, y;
    vector2(double a = 0, double b = 0) {
        x = a;
        y = b;

    }
};

// Structures for shapes


struct Line {
    int x1, y1, x2, y2;
    COLORREF color;
    int algorithm;

};

struct Circle {
    int xc, yc, R;
    COLORREF color;
    int quarter; // 1 to 4 for quarter-based drawing
    int algorithm; // 0: Direct, 1: Polar, 2: Iterative Polar, 3: Midpoint, 4: Modified Midpoint, 5: Fill Lines, 6: Fill Circles
};

struct Point {
    int x, y;
    Point(int x = 0, int y = 0) : x(x), y(y) {}
};

struct BezierCurve {
    Point p0, p1, p2, p3;
    COLORREF c0, c1, c2, c3;
};

struct HermiteCurve {
    Point p0, p1, t0, t1;
    COLORREF color;
};

struct AdvancedShape {
    std::string type;
    std::vector<Point> points;
    COLORREF color;
};

struct Entry {
    int xmin, xmax;
};

struct Polygonc {
    vector<Point> p;
    int xl, xr, yb, yt;
    COLORREF color;


};

struct EdgeRec {
    double x;
    double minv;
    int ymax;
    bool operator<(const EdgeRec& r) const { return x < r.x; }
};
struct Ellipsee {
    int xc, yc, a, b;
    COLORREF color;
    int quarter; // 1 to 4 for quarter-based drawing
    int algorithm; // 0: Direct, 1: Polar, 2: Iterative Polar, 3: Midpoint, 4: Modified Midpoint, 5: Fill Lines, 6: Fill Circles
};
struct Splines {
    int n;
    vector<Point> p;
    double c;
    COLORREF color;
};

typedef std::list<EdgeRec> EdgeList;


vector<Point> pointsArray;
vector<Line> lines;
vector<Circle> circles;
vector<BezierCurve> bezierCurves;
vector<HermiteCurve> hermiteCurves;
vector<AdvancedShape> advancedShapes;
vector<Ellipsee> ellipses;
vector<Splines>splines;
vector<Polygonc>polygons;



int splinesSize;
double mytenstion;



COLORREF currentColor = RGB(0, 0, 0); // Default: black
HBRUSH bgBrush = CreateSolidBrush(RGB(255, 255, 255)); // White
POINT tempPoint;
bool firstClick = true;
std::vector<Point> tempPoints;
std::vector<COLORREF> tempColors;
static int windowWidth = 800;
static int windowHeight = 600;
int commandID;

enum ShapeType { NONE,point ,LINE, CIRCLE, ELLIPSE, BEZIER, HERMITE, SPLINES, SQUARE_HERMITE, RECTANGLE_BEZIER, POLYGON, POLYGON_CONVEX, POLYGON_NONCONVEX, FLOOD_RECURSIVE, FLOOD_NON_RECURSIVE, EMPTY_SQUARE, Rec, Square };
ShapeType currentShapeType = LINE;
enum LineAlgorithm { DDA, BRESENHAM, PARAMETRIC };
enum CircleAlgorithm { DIRECT, POLAR, ITERATIVE_POLAR, MIDPOINT, MODIFIED_MIDPOINT, FILL_LINES, FILL_CIRCLES };
enum ClippingMethod { None = 0, RECTANGLE = 1, SQUARE = 2 };


enum EllipseAlgorithm { DIRECTE, POLARE, MIDPOINTE };


LineAlgorithm currentLineAlgorithm = DDA;
CircleAlgorithm currentCircleAlgorithm = DIRECT;
int currentQuarter = 1; // Default quarter
ClippingMethod currentClippingMethod = None;
EllipseAlgorithm ellipseAlgorithm = DIRECTE;


// Circle functions
void Draw8Points(HDC hdc, int xc, int yc, int x, int y, COLORREF c) {
    SetPixel(hdc, xc + x, yc + y, c);
    SetPixel(hdc, xc - x, yc + y, c);
    SetPixel(hdc, xc + x, yc - y, c);
    SetPixel(hdc, xc - x, yc - y, c);
    SetPixel(hdc, xc + y, yc + x, c);
    SetPixel(hdc, xc - y, yc + x, c);
    SetPixel(hdc, xc + y, yc - x, c);
    SetPixel(hdc, xc - y, yc - x, c);
}

void DrawPointsQuarter(HDC hdc, int xc, int yc, int x, int y, COLORREF c, int quarter) {
    switch (quarter) {
    case 1: // Top-right
        SetPixel(hdc, xc + x, yc - y, c);
        SetPixel(hdc, xc + y, yc - x, c);
        break;
    case 2: // Top-left
        SetPixel(hdc, xc - x, yc - y, c);
        SetPixel(hdc, xc - y, yc - x, c);
        break;
    case 3: // Bottom-left
        SetPixel(hdc, xc - x, yc + y, c);
        SetPixel(hdc, xc - y, yc + x, c);
        break;
    case 4: // Bottom-right
        SetPixel(hdc, xc + x, yc + y, c);
        SetPixel(hdc, xc + y, yc + x, c);
        break;
    }
}

void CircleDirectQuarter(HDC hdc, int xc, int yc, int R, COLORREF c, int quarter) {
    int x = 0;
    int y = R;
    while (x <= y) {
        y = (int)round(sqrt(R * R - x * x));
        DrawPointsQuarter(hdc, xc, yc, x, y, c, quarter);
        x++;
    }
}

void DDAHorizontalLine(HDC hdc, int x1, int x2, int y, COLORREF c) {
    if (x1 > x2) std::swap(x1, x2);
    for (int x = x1; x <= x2; x++)
        SetPixel(hdc, x, y, c);
}

void FillCircleWithLines(HDC hdc, int xc, int yc, int R, int quarter, COLORREF c) {
    for (int y = 0; y <= R; y++) {
        int x = (int)round(sqrt(R * R - y * y));
        switch (quarter) {
        case 1: // Top-right
            DDAHorizontalLine(hdc, xc, xc + x, yc - y, c);
            break;
        case 2: // Top-left
            DDAHorizontalLine(hdc, xc - x, xc, yc - y, c);
            break;
        case 3: // Bottom-left
            DDAHorizontalLine(hdc, xc - x, xc, yc + y, c);
            break;
        case 4: // Bottom-right
            DDAHorizontalLine(hdc, xc, xc + x, yc + y, c);
            break;
        }
    }
}

void FillCircleWithCircles(HDC hdc, int xc, int yc, int R, int quarter, COLORREF c) {
    for (int r = 0; r <= R; r++) {
        CircleDirectQuarter(hdc, xc, yc, r, c, quarter);
    }
}

void CircleDirect(HDC hdc, int xc, int yc, int R, COLORREF c) {
    int x = 0;
    int y = R;
    while (x <= y) {
        y = (int)round(sqrt(R * R - x * x));
        Draw8Points(hdc, xc, yc, x, y, c);
        x++;
    }
}

void CirclePolar(HDC hdc, int xc, int yc, int R, COLORREF c) {
    int x, y;
    double theta = 0, dtheta = 1.0 / R;
    while (theta <= 3.14159 / 4) {
        x = (int)round(R * cos(theta));
        y = (int)round(R * sin(theta));
        Draw8Points(hdc, xc, yc, x, y, c);
        theta += dtheta;
    }
}

void CircleIterativePolar(HDC hdc, int xc, int yc, int R, COLORREF c) {
    double x = R, y = 0;
    double dtheta = 1.0 / R;
    double cos_d = cos(dtheta), sin_d = sin(dtheta);
    while (x > y) {
        Draw8Points(hdc, xc, yc, (int)round(x), (int)round(y), c);
        double x1 = x * cos_d - y * sin_d;
        y = x * sin_d + y * cos_d;
        x = x1;
    }
}

void CircleMidpoint(HDC hdc, int xc, int yc, int R, COLORREF c) {
    int x = 0, y = R;
    int d = 1 - R;
    Draw8Points(hdc, xc, yc, x, y, c);
    while (x < y) {
        if (d < 0)
            d += 2 * x + 3;
        else {
            d += 2 * (x - y) + 5;
            y--;
        }
        x++;
        Draw8Points(hdc, xc, yc, x, y, c);
    }
}

void CircleModifiedMidpoint(HDC hdc, int xc, int yc, int R, COLORREF c) {
    int x = 0, y = R;
    int d = 1 - R;
    int d1 = 3, d2 = 5 - 2 * R;
    Draw8Points(hdc, xc, yc, x, y, c);
    while (x < y) {
        x++;
        if (d < 0) {
            d += d1;
            d1 += 2;
            d2 += 2;
        }
        else {
            y--;
            d += d2;
            d1 += 2;
            d2 += 4;
        }
        Draw8Points(hdc, xc, yc, x, y, c);
    }
}

/////////////////////////////////////////////////////////////////////////////////////////////////////////

//ELLIPSE



void Draw4Points(HDC hdc, int xc, int yc, int x, int y, COLORREF c) {

    SetPixel(hdc, xc + x, yc + y, c);
    SetPixel(hdc, xc - x, yc + y, c);
    SetPixel(hdc, xc + x, yc - y, c);
    SetPixel(hdc, xc - x, yc - y, c);


}
// a is width and b is height
void ellipseDirect(HDC hdc, int xc, int yc, int a, int b, COLORREF c) {
    int xRegion1 = 0;
    int yRegion1;
    while (xRegion1 <= a) {



        yRegion1 = (int)round(b * sqrt(1 - (double)(xRegion1 * xRegion1) / (a * a)));
        Draw4Points(hdc, xc, yc, xRegion1, yRegion1, c);
        xRegion1++;
    }
    int xRegion2;
    int yRegion2 = 0;


    while (yRegion2 <= b) {
        xRegion2 = (int)round(a * sqrt(1 - (double)(yRegion2 * yRegion2) / (b * b)));
        Draw4Points(hdc, xc, yc, xRegion2, yRegion2, c);
        yRegion2++;
    }


}

void ellipsePolar(HDC hdc, int xc, int yc, int a, int b, COLORREF c) {
    int x, y;
    double theta = 0, dtheta = 1.0 / max(a, b);
    while (theta <= 2 * 3.14159265) {
        x = (int)round(a * cos(theta));
        y = (int)round(b * sin(theta));
        Draw4Points(hdc, xc, yc, x, y, c);
        theta += dtheta;
    }
}

void MidpointEllipse(HDC hdc, int xc, int yc, int a, int b, COLORREF c) {
    int a2 = a * a;
    int b2 = b * b;
    int x = 0, y = b;
    int d1 = b2 - a2 * b + (a2 / 4);
    int dx = 2 * b2 * x;
    int dy = 2 * a2 * y;

    Draw4Points(hdc, xc, yc, x, y, c);

    while (dx < dy) {
        x++;
        dx += 2 * b2;
        if (d1 < 0) {
            d1 += dx + b2;
        }
        else {
            y--;
            dy -= 2 * a2;
            d1 += dx - dy + b2;
        }
        Draw4Points(hdc, xc, yc, x, y, c);
    }

    int d2 = b2 * (x + 0.5) * (x + 0.5) + a2 * (y - 1) * (y - 1) - a2 * b2;
    while (y > 0) {
        y--;
        dy -= 2 * a2;
        if (d2 > 0) {
            d2 += a2 - dy;
        }
        else {
            x++;
            dx += 2 * b2;
            d2 += dx - dy + a2;
        }
        Draw4Points(hdc, xc, yc, x, y, c);
    }
}




///////////////////////////////////////////////////////////////////////////////////////////////////
//      lines
void DrawLineDDA(HDC hdc, int x1, int y1, int x2, int y2, COLORREF c)
{

    int dx = x2 - x1;
    int dy = y2 - y1;
    double x = x1;
    double	y = y1;

    SetPixel(hdc, x, y, c);
    if (abs(dx) >= abs(dy))
    {
        int xi = dx > 0 ? 1 : -1;
        double m = (double)dy / dx * xi;
        while (x != x2)
        {
            x += xi;
            y += m;
            SetPixel(hdc, x, round(y), c);
        }
    }

    else {
        int yi = dy > 0 ? 1 : -1;
        double m = (double)dx / dy * yi;

        while (y != y2) {
            y += yi;
            x += m;
            SetPixel(hdc, round(x), y, c);
        }
    }
}
void DrawLineBres(HDC hdc, int x1, int y1, int x2, int y2, COLORREF c)
{
    if (x2 < x1) {
        swap(x1, x2);
        swap(y1, y2);
    }

    int dx = abs(x2 - x1);
    int dy = abs(y2 - y1);

    // if line is vertical
    if (dx == 0) {
        int y = y1;
        if (y < y2) {
            while (y <= y2) {
                SetPixel(hdc, x1, y, c);
                y += 1;
            }
        }
        else {
            while (y >= y2) {
                SetPixel(hdc, x1, y, c);
                y -= 1;
            }
        }
        return;
    }


    int x = x1, y = y1;
    int sy = (y2 >= y1) ? 1 : -1;

    bool isSteep = dy > dx;

    if (isSteep) swap(dx, dy);

    int d = -2 * dy + dx;
    int d1 = -2 * dy;
    int d2 = 2 * (dx - dy);

    SetPixel(hdc, x, y, c);

    while (x < x2) {
        if (d < 0) {
            d += d2;
            if (isSteep) x += 1;
            else y += sy;
        }
        else {
            d += d1;
        }

        if (isSteep) y += sy;
        else x += 1;

        SetPixel(hdc, x, y, c);
    }
}
void ParametricLine(HDC hdc, int x1, int y1, int x2, int y2, COLORREF c1)
{
    int alpha1 = x2 - x1;
    int alpha2 = y2 - y1;

    double steps = 1.0 / max(abs(alpha1),
        abs(alpha2));

    SetPixel(hdc, x1, y1, c1);
    for (double t = 0; t < 1; t += steps)
    {

        double x = (alpha1 * t) + x1;
        double y = (alpha2 * t) + y1;

        SetPixel(hdc, Round(x), Round(y), c1);
    }
    SetPixel(hdc, x2, y2, c1);
}


/////////////////////////////////////////////////////////////////////////////////////////
// 
//-----------------------------------------------------------------
POINT points[2];
int pointCount = 0;
int xmin, ymin, xmax, ymax;

//-------------------------------------------------------------------
//clip point
void clippingPoint(HDC hdc, int x, int y, COLORREF c) {
    if (x >= xmin && x <= xmax && y >= ymin && y <= ymax) {
        SetPixel(hdc, x, y, c);
    }

}
//-----------------------------------------------------------------
union OutCode
{
    unsigned All : 4;
    struct { unsigned left : 1, top : 1, right : 1, bottom : 1; };
};

OutCode GetOutCode(double x, double y)
{
    OutCode out;
    out.All = 0;
    if (x < xmin) out.left = 1;
    else if (x > xmax) out.right = 1;

    if (y < ymin) out.top = 1;
    else if (y > ymax) out.bottom = 1;

    return out;
}


Point VIntersect(Point& p1, Point& p2, int xedge) {
    Point result;
    result.x = xedge;
    if (p2.x - p1.x == 0)  // vertical line 
        result.y = p1.y;
    else
        result.y = ((xedge - p1.x) * (p2.y - p1.y) / (p2.x - p1.x)) + p1.y;
    return result;
}

Point HIntersect(Point& p1, Point& p2, int yedge) {
    Point result;
    result.y = yedge;
    if (p2.y - p1.y == 0)  // if line is horizontal
        result.x = p1.x;
    else
        result.x = ((yedge - p1.y) * (p2.x - p1.x) / (p2.y - p1.y)) + p1.x;
    return result;
}


bool ClipLine(Point& p1, Point& p2) {
    OutCode out1 = GetOutCode(p1.x, p1.y);
    OutCode out2 = GetOutCode(p2.x, p2.y);

    while (true) {
        if (out1.All == 0 && out2.All == 0) return true;

        if ((out1.All & out2.All) != 0) return false;

        if (out1.All) {
            if (out1.left)   p1 = VIntersect(p1, p2, xmin);
            if (out1.right)  p1 = VIntersect(p1, p2, xmax);
            if (out1.top)    p1 = HIntersect(p1, p2, ymin);
            if (out1.bottom) p1 = HIntersect(p1, p2, ymax);

            out1 = GetOutCode(p1.x, p1.y);
        }
        else {
            if (out2.left)   p2 = VIntersect(p1, p2, xmin);
            if (out2.right)  p2 = VIntersect(p1, p2, xmax);
            if (out2.top)    p2 = HIntersect(p1, p2, ymin);
            if (out2.bottom) p2 = HIntersect(p1, p2, ymax);

            out2 = GetOutCode(p2.x, p2.y);
        }

    }
}




/////////////////////////////////////////////////////////////////////////


typedef vector<Point>PolygonPoints;

typedef bool (*IsInFunc)(Point& v, int edge);
typedef Point(*IntersectFunc)(Point& v1, Point& v2, int edge);

PolygonPoints ClipWithEdge(PolygonPoints p, int edge, IsInFunc In, IntersectFunc Intersect)
{
    PolygonPoints OutList;
    Point v1 = p[p.size() - 1];
    bool v1_in = In(v1, edge);
    for (int i = 0; i < (int)p.size(); i++)
    {
        Point v2 = p[i];
        bool v2_in = In(v2, edge);
        if (!v1_in && v2_in)
        {

            OutList.push_back(Intersect(v1, v2, edge));
            OutList.push_back(v2);
        }
        else if (v1_in && v2_in) OutList.push_back(v2);
        else if (v1_in) OutList.push_back(Intersect(v1, v2, edge));
        v1 = v2;
        v1_in = v2_in;
    }
    return OutList;
}


bool InLeft(Point& v, int edge)
{
    return v.x >= edge;
}
bool InRight(Point& v, int edge)
{
    return v.x <= edge;
}
bool InTop(Point& v, int edge)
{
    return v.y >= edge;
}
bool InBottom(Point& v, int edge)
{
    return v.y <= edge;
}





void PolygonClip(HDC hdc, vector<Point> p, int xl, int xr, int yt, int yb, COLORREF c) {


    p = ClipWithEdge(p, xl, InLeft, VIntersect);
    p = ClipWithEdge(p, xr, InRight, VIntersect);
    p = ClipWithEdge(p, yt, InTop, HIntersect);
    p = ClipWithEdge(p, yb, InBottom, HIntersect);
    Point v1 = p[p.size() - 1];

    HPEN hPen = CreatePen(PS_SOLID, 1, c);
    HPEN hOldPen = (HPEN)SelectObject(hdc, hPen);

    for (int i = 0; i < p.size(); i++)
    {
        Point v2 = p[i];


        MoveToEx(hdc, Round(v1.x), Round(v1.y), NULL);
        LineTo(hdc, Round(v2.x), Round(v2.y));



        v1 = v2;
    }
    SelectObject(hdc, hOldPen);
    DeleteObject(hPen);





}







//////////////////////////////////////////////////////////////////







// Bezier

void DrawBezierCurve(HDC hdc, Point p0, COLORREF c0, Point p1, COLORREF c1, Point p2, COLORREF c2, Point p3, COLORREF c3) {
    const int STEPS = 50;

    for (double i = 0; i <= STEPS; i += 0.02) {
        //   0 < t < 1
        double t = (double)i / STEPS;
        double u = 1.0 - t;

        // Cubic Bezier curve equation ((1-t) + t)^3
        // x = x0*(1-t)^3 + x1*3t*(1-t)^2 + x2*3t^2(1-t) + x3*t^3
        double x = pow(u, 3) * p0.x + 3 * pow(u, 2) * t * p1.x + 3 * u * pow(t, 2) * p2.x + pow(t, 3) * p3.x;

        // y = y0*(1-t)^3 + y1*3t*(1-t)^2 + y2*3t^2(1-t) + y3*t^3
        double y = pow(u, 3) * p0.y + 3 * pow(u, 2) * t * p1.y + 3 * u * pow(t, 2) * p2.y + pow(t, 3) * p3.y;

        int r0 = GetRValue(c0), g0 = GetGValue(c0), b0 = GetBValue(c0);
        int r1 = GetRValue(c1), g1 = GetGValue(c1), b1 = GetBValue(c1);
        int r2 = GetRValue(c2), g2 = GetGValue(c2), b2 = GetBValue(c2);
        int r3 = GetRValue(c3), g3 = GetGValue(c3), b3 = GetBValue(c3);

        int r = (int)(pow(u, 3) * r0 + 3 * pow(u, 2) * t * r1 + 3 * u * pow(t, 2) * r2 + pow(t, 3) * r3);
        int g = (int)(pow(u, 3) * g0 + 3 * pow(u, 2) * t * g1 + 3 * u * pow(t, 2) * g2 + pow(t, 3) * g3);
        int b = (int)(pow(u, 3) * b0 + 3 * pow(u, 2) * t * b1 + 3 * u * pow(t, 2) * b2 + pow(t, 3) * b3);

        // To make sure that colors in the range and rounded
        r = (r < 0) ? 0 : (r > 255) ? 255 : r;
        g = (g < 0) ? 0 : (g > 255) ? 255 : g;
        b = (b < 0) ? 0 : (b > 255) ? 255 : b;

        SetPixel(hdc, (int)x, (int)y, RGB(r, g, b));

    }
}

void DrawHermiteCurve(HDC hdc, Point p0, Point p1, Point t0, Point t1, COLORREF color) {
    const int STEPS = 50;
    HPEN hPen = CreatePen(PS_SOLID, 2, color);
    HPEN hOldPen = (HPEN)SelectObject(hdc, hPen);
    MoveToEx(hdc, p0.x, p0.y, NULL);

    for (double i = 0; i <= STEPS; i += 0.02) {
        double t = (double)i / STEPS;
        double t2 = t * t;
        double t3 = t2 * t;

        double first = 2 * t3 - 3 * t2 + 1;
        double second = t3 - 2 * t2 + t;
        double third = -2 * t3 + 3 * t2;
        double fourth = t3 - t2;

        double x = first * p0.x + second * t0.x + third * p1.x + fourth * t1.x;
        double y = first * p0.y + second * t0.y + third * p1.y + fourth * t1.y;
        LineTo(hdc, (int)x, (int)y);
    }
    SelectObject(hdc, hOldPen);
    DeleteObject(hPen);
}



void DrawCardinalSpline(HDC hdc, vector<Point>P, int n, double c, COLORREF color1)
{


    if (n < 2) return;

    std::vector<Point> newPoints;
    newPoints.push_back(P[0]);
    newPoints.insert(newPoints.end(), P.begin(), P.end());
    newPoints.push_back(P[n - 1]);

    double c1 = 1 - c;
    Point T0(c1 * (newPoints[2].x - newPoints[0].x), c1 * (newPoints[2].y - newPoints[0].y));

    for (int i = 2; i < newPoints.size() - 1; i++) {
        Point T1(c1 * (newPoints[i + 1].x - newPoints[i - 1].x),
            c1 * (newPoints[i + 1].y - newPoints[i - 1].y));

        DrawHermiteCurve(hdc, newPoints[i - 1], newPoints[i], T0, T1, color1);
        T0 = T1;
    }
}




void FillSquareWithHermiteCurve(HDC hdc, Point topLeft, int size, COLORREF color) {
    MoveToEx(hdc, topLeft.x, topLeft.y, NULL);
    LineTo(hdc, topLeft.x + size, topLeft.y);
    LineTo(hdc, topLeft.x + size, topLeft.y + size);
    LineTo(hdc, topLeft.x, topLeft.y + size);
    LineTo(hdc, topLeft.x, topLeft.y);
    for (int x = topLeft.x; x <= topLeft.x + size; x += 2) {
        Point p0(x, topLeft.y);
        Point p1(x, topLeft.y + size);
        Point t0(0, size / 4);
        Point t1(0, -size / 4);
        DrawHermiteCurve(hdc, p0, p1, t0, t1, color);
    }
}

void FillRectangleWithBezierCurve(HDC hdc, Point topLeft, Point bottomRight, COLORREF color) {
    MoveToEx(hdc, topLeft.x, topLeft.y, NULL);
    LineTo(hdc, bottomRight.x, topLeft.y);
    LineTo(hdc, bottomRight.x, bottomRight.y);
    LineTo(hdc, topLeft.x, bottomRight.y);
    LineTo(hdc, topLeft.x, topLeft.y);

    int width = bottomRight.x - topLeft.x;
    for (int y = topLeft.y; y <= bottomRight.y; y += 1) {
        Point p0(topLeft.x, y);
        Point p1(topLeft.x + width / 3, y);
        Point p2(topLeft.x + 2 * width / 3, y);
        Point p3(bottomRight.x, y);
        DrawBezierCurve(hdc, p0, color, p1, color, p2, color, p3, color);
    }
}

void DrawEmptySquare(HDC hdc, Point topLeft, int size, COLORREF color) {
    HPEN hPen = CreatePen(PS_SOLID, 2, color);
    HPEN hOldPen = (HPEN)SelectObject(hdc, hPen);

    MoveToEx(hdc, topLeft.x, topLeft.y, NULL);
    LineTo(hdc, topLeft.x + size, topLeft.y);
    LineTo(hdc, topLeft.x + size, topLeft.y + size);
    LineTo(hdc, topLeft.x, topLeft.y + size);
    LineTo(hdc, topLeft.x, topLeft.y);

    SelectObject(hdc, hOldPen);
    DeleteObject(hPen);
}

void FloodFillRecursive(HDC hdc, int x, int y, COLORREF fillColor, COLORREF boundaryColor) {
    if (x < 0 || x >= windowWidth || y < 0 || y >= windowHeight) return;
    COLORREF currentColor = GetPixel(hdc, x, y);
    if (currentColor == boundaryColor || currentColor == fillColor) return;
    SetPixel(hdc, x, y, fillColor);
    FloodFillRecursive(hdc, x + 1, y, fillColor, boundaryColor);
    FloodFillRecursive(hdc, x - 1, y, fillColor, boundaryColor);
    FloodFillRecursive(hdc, x, y + 1, fillColor, boundaryColor);
    FloodFillRecursive(hdc, x, y - 1, fillColor, boundaryColor);
}

void FloodFillNonRecursive(HDC hdc, int x, int y, COLORREF fillColor, COLORREF boundaryColor) {
    std::stack<Point> stack;
    stack.push(Point(x, y));
    while (!stack.empty()) {
        Point p = stack.top();
        stack.pop();
        COLORREF currentColor = GetPixel(hdc, p.x, p.y);
        if (currentColor == boundaryColor || currentColor == fillColor) continue;
        SetPixel(hdc, p.x, p.y, fillColor);
        stack.push(Point(p.x + 1, p.y));
        stack.push(Point(p.x - 1, p.y));
        stack.push(Point(p.x, p.y + 1));
        stack.push(Point(p.x, p.y - 1));
    }
}

void InitEntries(Entry table[]) {
    for (int i = 0; i < MAXENTRIES; i++) {
        table[i].xmin = INT_MAX;
        table[i].xmax = INT_MIN;
    }
}

void ScanEdge(POINT v1, POINT v2, Entry table[]) {
    if (v1.y == v2.y) return;
    if (v1.y > v2.y) std::swap(v1, v2);
    double minv = (double)(v2.x - v1.x) / (v2.y - v1.y);
    double x = v1.x;
    int y = v1.y;
    while (y < v2.y) {
        if (x < table[y].xmin) table[y].xmin = (int)ceil(x);
        if (x > table[y].xmax) table[y].xmax = (int)floor(x);
        y++;
        x += minv;
    }
}

void DrawScanLines(HDC hdc, Entry table[], COLORREF color) {
    for (int y = 0; y < MAXENTRIES; y++) {
        if (table[y].xmin < table[y].xmax) {
            for (int x = table[y].xmin; x <= table[y].xmax; x++) {
                SetPixel(hdc, x, y, color);
            }
        }
    }
}

void ConvexFill(HDC hdc, POINT p[], int n, COLORREF color) {
    Entry* table = new Entry[MAXENTRIES];
    InitEntries(table);
    POINT v1 = p[n - 1];
    for (int i = 0; i < n; i++) {
        POINT v2 = p[i];
        ScanEdge(v1, v2, table);
        v1 = p[i];
    }
    DrawScanLines(hdc, table, color);
    delete[] table;
}

EdgeRec InitEdgeRec(POINT& v1, POINT& v2) {
    if (v1.y > v2.y) std::swap(v1, v2);
    EdgeRec rec;
    rec.x = v1.x;
    rec.ymax = v2.y;
    rec.minv = (double)(v2.x - v1.x) / (v2.y - v1.y);
    return rec;
}

void InitEdgeTable(POINT* polygon, int n, EdgeList table[]) {
    POINT v1 = polygon[n - 1];
    for (int i = 0; i < n; i++) {
        POINT v2 = polygon[i];
        if (v1.y == v2.y) { v1 = v2; continue; }
        EdgeRec rec = InitEdgeRec(v1, v2);
        table[v1.y].push_back(rec);
        v1 = polygon[i];
    }
}

void GeneralPolygonFill(HDC hdc, POINT* polygon, int n, COLORREF c) {
    EdgeList* table = new EdgeList[MAXENTRIES];
    InitEdgeTable(polygon, n, table);
    int y = 0;
    while (y < MAXENTRIES && table[y].size() == 0) y++;

    if (y == MAXENTRIES) {
        delete[] table;
        return;
    }

    EdgeList ActiveList = table[y];
    while (!ActiveList.empty()) {
        ActiveList.sort();
        for (EdgeList::iterator it = ActiveList.begin(); it != ActiveList.end(); ++it) {
            int x1 = (int)ceil(it->x);
            EdgeList::iterator nextIt = it;
            ++nextIt;
            if (nextIt != ActiveList.end()) {
                int x2 = (int)floor(nextIt->x);
                for (int x = x1; x <= x2; x++) {
                    SetPixel(hdc, x, y, c);
                }
            }
        }
        y++;
        EdgeList::iterator it = ActiveList.begin();
        while (it != ActiveList.end()) {
            if (y == it->ymax) {
                it = ActiveList.erase(it);
            }
            else {
                ++it;
            }
        }
        for (EdgeList::iterator it = ActiveList.begin(); it != ActiveList.end(); ++it) {
            it->x += it->minv;
        }
        ActiveList.insert(ActiveList.end(), table[y].begin(), table[y].end());
    }
    delete[] table;
}


RECT clippingRect = { 0,0,0,0 };
bool clippingEnabled = false;

RECT clippingSquare = { 0, 0, 0, 0 };
bool clippingEnabledSquare = false;

bool clippingRectDrawn = false;
bool clippingSquareDrawn = false;
void DrawClippingRectangle(HDC hdc) {
    if (clippingRectDrawn) {
        DrawLineBres(hdc, xmin, ymin, xmax, ymin, RGB(255, 0, 0));
        DrawLineBres(hdc, xmax, ymin, xmax, ymax, RGB(255, 0, 0));
        DrawLineBres(hdc, xmax, ymax, xmin, ymax, RGB(255, 0, 0));
        DrawLineBres(hdc, xmin, ymax, xmin, ymin, RGB(255, 0, 0));
    }
}

void DrawClippingSquare(HDC hdc) {
    if (clippingSquareDrawn) {
        DrawLineBres(hdc, xmin, ymin, xmax, ymin, RGB(255, 0, 0));
        DrawLineBres(hdc, xmax, ymin, xmax, ymax, RGB(255, 0, 0));
        DrawLineBres(hdc, xmax, ymax, xmin, ymax, RGB(255, 0, 0));
        DrawLineBres(hdc, xmin, ymax, xmin, ymin, RGB(255, 0, 0));
    }
}











void DrawAllShapes(HDC hdc) {
    // Draw lines
    if (currentClippingMethod == RECTANGLE && clippingEnabled) {
        xmin = clippingRect.left;
        ymin = clippingRect.top;
        xmax = clippingRect.right;
        ymax = clippingRect.bottom;

        DrawClippingRectangle(hdc);


    }
    else if (currentClippingMethod == SQUARE && clippingEnabledSquare) {
        xmin = clippingSquare.left;
        ymin = clippingSquare.top;
        xmax = clippingSquare.right;
        ymax = clippingSquare.bottom;

        DrawClippingSquare(hdc);
    }


    else {
        xmin = ymin = INT_MIN;
        xmax = ymax = INT_MAX;
    }


    // Draw lines
    for (auto& line : lines) {
        if (currentClippingMethod != None) {
            Point p1{ line.x1, line.y1 };
            Point p2{ line.x2, line.y2 };

            if (ClipLine(p1, p2)) {
                switch (line.algorithm) {
                case DDA:
                    DrawLineDDA(hdc, p1.x, p1.y, p2.x, p2.y, line.color);
                    break;
                case BRESENHAM:
                    DrawLineBres(hdc, p1.x, p1.y, p2.x, p2.y, line.color);
                    break;
                case PARAMETRIC:
                    ParametricLine(hdc, p1.x, p1.y, p2.x, p2.y, line.color);
                    break;
                }
            }
        }
        else {
            switch (line.algorithm) {
            case DDA:
                DrawLineDDA(hdc, line.x1, line.y1, line.x2, line.y2, line.color);
                break;
            case BRESENHAM:
                DrawLineBres(hdc, line.x1, line.y1, line.x2, line.y2, line.color);
                break;
            case PARAMETRIC:
                ParametricLine(hdc, line.x1, line.y1, line.x2, line.y2, line.color);
                break;
            }
        }

    }
    // Draw points
    for (int i = 0; i < pointsArray.size(); i++) {
        int x = pointsArray[i].x;
        int y = pointsArray[i].y;

        if ((clippingEnabled || clippingEnabledSquare)) {
            if (x >= xmin && x <= xmax && y >= ymin && y <= ymax)
                clippingPoint(hdc, x, y, RGB(255, 0, 0));
        }
        else {
            clippingPoint(hdc, x, y, RGB(255, 0, 0));
        }
    }

    // Draw circles
    for (auto& circle : circles) {
        switch (circle.algorithm) {
        case DIRECT:
            CircleDirect(hdc, circle.xc, circle.yc, circle.R, circle.color);
            break;
        case POLAR:
            CirclePolar(hdc, circle.xc, circle.yc, circle.R, circle.color);
            break;
        case ITERATIVE_POLAR:
            CircleIterativePolar(hdc, circle.xc, circle.yc, circle.R, circle.color);
            break;
        case MIDPOINT:
            CircleMidpoint(hdc, circle.xc, circle.yc, circle.R, circle.color);
            break;
        case MODIFIED_MIDPOINT:
            CircleModifiedMidpoint(hdc, circle.xc, circle.yc, circle.R, circle.color);
            break;
        case FILL_LINES:
            FillCircleWithLines(hdc, circle.xc, circle.yc, circle.R, circle.quarter, circle.color);
            CircleDirect(hdc, circle.xc, circle.yc, circle.R, circle.color); // Draw outline
            break;
        case FILL_CIRCLES:
            FillCircleWithCircles(hdc, circle.xc, circle.yc, circle.R, circle.quarter, circle.color);
            CircleDirect(hdc, circle.xc, circle.yc, circle.R, circle.color);
            break;
        }
    }



    for (auto& e : ellipses) {
        switch (e.algorithm) {
        case DIRECT:
            ellipseDirect(hdc, e.xc, e.yc, e.a, e.b, e.color);
            break;
        case POLAR:
            ellipsePolar(hdc, e.xc, e.yc, e.a, e.b, e.color);
            break;

        case MIDPOINT:
            MidpointEllipse(hdc, e.xc, e.yc, e.a, e.b, e.color);


        }
    }

    for (auto& polygon : polygons) {
        PolygonClip(hdc, polygon.p, polygon.xl, polygon.xr, polygon.yt, polygon.yb, polygon.color);
    }












    for (auto& bezier : bezierCurves) {
        DrawBezierCurve(hdc, bezier.p0, bezier.c0, bezier.p1, bezier.c1, bezier.p2, bezier.c2, bezier.p3, bezier.c3);
    }
    for (auto& hermite : hermiteCurves) {
        DrawHermiteCurve(hdc, hermite.p0, hermite.p1, hermite.t0, hermite.t1, hermite.color);
    }

    for (auto& spline : splines) {
        DrawCardinalSpline(hdc, spline.p, spline.n, spline.c, spline.color);
    }





    for (auto& shape : advancedShapes) {
        if (shape.type == "square_hermite" && shape.points.size() == 2) {
            int size = std::max(abs(shape.points[1].x - shape.points[0].x), abs(shape.points[1].y - shape.points[0].y));
            Point topLeft(std::min(shape.points[0].x, shape.points[1].x), std::min(shape.points[0].y, shape.points[1].y));
            FillSquareWithHermiteCurve(hdc, topLeft, size, shape.color);
        }
        else if (shape.type == "rectangle_bezier" && shape.points.size() == 2) {
            Point topLeft(std::min(shape.points[0].x, shape.points[1].x), std::min(shape.points[0].y, shape.points[1].y));
            Point bottomRight(std::max(shape.points[0].x, shape.points[1].x), std::max(shape.points[0].y, shape.points[1].y));
            FillRectangleWithBezierCurve(hdc, topLeft, bottomRight, shape.color);
        }
        else if (shape.type == "empty_square" && shape.points.size() == 2) {
            int size = std::max(abs(shape.points[1].x - shape.points[0].x), abs(shape.points[1].y - shape.points[0].y));
            Point topLeft(std::min(shape.points[0].x, shape.points[1].x), std::min(shape.points[0].y, shape.points[1].y));
            DrawEmptySquare(hdc, topLeft, size, shape.color);
        }
        else if (shape.type == "polygon_convex" && shape.points.size() >= 3) {
            POINT* pArray = new POINT[shape.points.size()];
            for (size_t i = 0; i < shape.points.size(); i++) {
                pArray[i].x = shape.points[i].x;
                pArray[i].y = shape.points[i].y;
            }
            ConvexFill(hdc, pArray, shape.points.size(), shape.color);
            delete[] pArray;
        }
        else if (shape.type == "polygon_nonconvex" && shape.points.size() >= 4) {
            POINT* pArray = new POINT[shape.points.size()];
            for (size_t i = 0; i < shape.points.size(); i++) {
                pArray[i].x = shape.points[i].x;
                pArray[i].y = shape.points[i].y;
            }
            GeneralPolygonFill(hdc, pArray, shape.points.size(), shape.color);
            delete[] pArray;
        }
    }
}




void SaveData() {
    std::ofstream file("shapes.txt");
    // Save lines
    file << "Lines\n";

    for (auto& line : lines) {
        file << line.x1 << " " << line.y1 << " "
            << line.x2 << " " << line.y2 << " "
            << (int)GetRValue(line.color) << " "
            << (int)GetGValue(line.color) << " "
            << (int)GetBValue(line.color) << " " << line.algorithm << "\n";
    }
    file << "ClippingMethod " << (int)currentClippingMethod << "\n";

    file << "ClippingRect "
        << clippingRect.left << " " << clippingRect.top << " "
        << clippingRect.right << " " << clippingRect.bottom << "\n";

    file << "ClippingSquare "
        << clippingSquare.left << " " << clippingSquare.top << " "
        << clippingSquare.right << " " << clippingSquare.bottom << "\n";

    // Save circles
    file << "Circles\n";
    for (auto& circle : circles) {
        file << circle.xc << " " << circle.yc << " " << circle.R << " "
            << (int)GetRValue(circle.color) << " "
            << (int)GetGValue(circle.color) << " "
            << (int)GetBValue(circle.color) << " "
            << circle.quarter << " " << circle.algorithm << "\n";
    }


    // Save Ellipse
    file << "Ellipse\n";
    for (auto& e : ellipses) {
        file << e.xc << " " << e.yc << " " << e.a << " " << e.b << " "
            << (int)GetRValue(e.color) << " "
            << (int)GetGValue(e.color) << " "
            << (int)GetBValue(e.color) << " "
            << e.quarter << " " << e.algorithm << "\n";
    }






    file << "Spline\n";
    for (auto& spline : splines) {
        file << spline.n << " ";
        for (int i = 0; i < spline.n; i++) {
            file << spline.p[i].x << " " << spline.p[i].y << " ";
        }
        file << spline.c << " ";
        file << (int)GetRValue(spline.color) << " "
            << (int)GetGValue(spline.color) << " "
            << (int)GetBValue(spline.color) << "\n";
    }

    file << "Polygon\n";
    for (auto& polygon : polygons) {
        for (int i = 0; i < 4; i++) {
            file << polygon.p[i].x << " " << polygon.p[i].y << " ";
        }

        file << (int)GetRValue(polygon.color) << " "
            << (int)GetGValue(polygon.color) << " "
            << (int)GetBValue(polygon.color) << "\n";
    }







    file << "BezierCurves\n";
    for (auto& bezier : bezierCurves) {
        file << bezier.p0.x << " " << bezier.p0.y << " "
            << bezier.p1.x << " " << bezier.p1.y << " "
            << bezier.p2.x << " " << bezier.p2.y << " "
            << bezier.p3.x << " " << bezier.p3.y << " "
            << (int)GetRValue(bezier.c0) << " " << (int)GetGValue(bezier.c0) << " " << (int)GetBValue(bezier.c0) << " "
            << (int)GetRValue(bezier.c1) << " " << (int)GetGValue(bezier.c1) << " " << (int)GetBValue(bezier.c1) << " "
            << (int)GetRValue(bezier.c2) << " " << (int)GetGValue(bezier.c2) << " " << (int)GetBValue(bezier.c2) << " "
            << (int)GetRValue(bezier.c3) << " " << (int)GetGValue(bezier.c3) << " " << (int)GetBValue(bezier.c3) << "\n";
    }
    file << "HermiteCurves\n";
    for (auto& hermite : hermiteCurves) {
        file << hermite.p0.x << " " << hermite.p0.y << " "
            << hermite.p1.x << " " << hermite.p1.y << " "
            << hermite.t0.x << " " << hermite.t0.y << " "
            << hermite.t1.x << " " << hermite.t1.y << " "
            << (int)GetRValue(hermite.color) << " " << (int)GetGValue(hermite.color) << " " << (int)GetBValue(hermite.color) << "\n";
    }
    file << "AdvancedShapes\n";
    for (auto& shape : advancedShapes) {
        file << shape.type << " " << shape.points.size() << " ";
        for (const auto& p : shape.points) {
            file << p.x << " " << p.y << " ";
        }
        file << (int)GetRValue(shape.color) << " " << (int)GetGValue(shape.color) << " " << (int)GetBValue(shape.color) << "\n";
    }
    file.close();
    std::cout << "Saved " << lines.size() << " line(s), "<< pointsArray.size() << " point(s), " << circles.size() << " circle(s), " << ellipses.size() << " ellipse(s), "
        << bezierCurves.size() << " Bezier curve(s), " << hermiteCurves.size() << " Hermite curve(s), " << splines.size() << " spline(s) " << polygons.size() << " Polygon(s) "
        << advancedShapes.size() << " advanced shape(s) to shapes.txt\n";
}





void LoadData(HWND hwnd) {
    std::ifstream file("shapes.txt");
    if (!file.is_open()) {
        std::cout << "Could not open shapes.txt\n";
        return;
    }

    lines.clear();
    pointsArray.clear();
    circles.clear();
    ellipses.clear();
    bezierCurves.clear();
    hermiteCurves.clear();
    advancedShapes.clear();
    polygons.clear();
    splines.clear();
    tempPoints.clear();
    tempColors.clear();
    std::string lineType;
    int countLines = 0, countPolygons = 0, countCircles = 0, countEllipse = 0, countBeziers = 0, countHermites = 0, countAdvanced = 0, coutSplines = 0;

    while (std::getline(file, lineType)) {
        if (lineType == "Lines") {
            Line l;
            int r, g, b;
            while (file >> l.x1 >> l.y1 >> l.x2 >> l.y2 >> r >> g >> b) {
                l.color = RGB(r, g, b);
                lines.push_back(l);
                countLines++;
                // Peek next token without extracting it
                std::streampos pos = file.tellg();
                std::string nextToken;
                if (!(file >> nextToken)) break; // EOF reached
                if (nextToken == "Circles" || nextToken == "ClippingMethod" || nextToken == "ClippingRect" || nextToken == "ClippingSquare" || nextToken == "Lines") {
                    // Go back to the position before reading nextToken
                    file.seekg(pos);
                    break;
                }
                else {
                    // Not a section header, continue parsing lines
                    file.seekg(pos);
                }
            }
        }

        else if (lineType == "Circles") {
            Circle c;
            int r, g, b;
            while (file >> c.xc >> c.yc >> c.R >> r >> g >> b >> c.quarter >> c.algorithm) {
                c.color = RGB(r, g, b);
                circles.push_back(c);
                countCircles++;
                if (file.peek() == EOF || file.peek() == '\n') break;
            }
        }


        else if (lineType == "Ellipse") {
            Ellipsee e;
            int r, g, b;
            while (file >> e.xc >> e.yc >> e.a >> e.b >> r >> g >> b >> e.quarter >> e.algorithm) {
                e.color = RGB(r, g, b);
                ellipses.push_back(e);
                countEllipse++;
                if (file.peek() == EOF || file.peek() == '\n') break;
            }
        }

        else if (lineType == "Polygon") {
            Polygonc polygon;
            int r, g, b;


            for (int i = 0; i < 4; i++) {
                file >> polygon.p[i].x >> polygon.p[i].y;
            }

            file >> r >> g >> b;
            polygon.color = RGB(r, g, b);
            polygons.push_back(polygon);
            countPolygons++;

            if (file.peek() == EOF || file.peek() == '\n') break;
        }





        else if (lineType == "BezierCurves") {
            BezierCurve b;
            int r0, g0, b0, r1, g1, b1, r2, g2, b2, r3, g3, b3;
            while (file >> b.p0.x >> b.p0.y >> b.p1.x >> b.p1.y >> b.p2.x >> b.p2.y >> b.p3.x >> b.p3.y
                >> r0 >> g0 >> b0 >> r1 >> g1 >> b1 >> r2 >> g2 >> b2 >> r3 >> g3 >> b3) {
                b.c0 = RGB(r0, g0, b0);
                b.c1 = RGB(r1, g1, b1);
                b.c2 = RGB(r2, g2, b2);
                b.c3 = RGB(r3, g3, b3);
                bezierCurves.push_back(b);
                countBeziers++;
                if (file.peek() == '\n' || file.peek() == EOF) break;
            }
        }
        else if (lineType == "HermiteCurves") {
            HermiteCurve h;
            int r, g, b;
            while (file >> h.p0.x >> h.p0.y >> h.p1.x >> h.p1.y >> h.t0.x >> h.t0.y >> h.t1.x >> h.t1.y >> r >> g >> b) {
                h.color = RGB(r, g, b);
                hermiteCurves.push_back(h);
                countHermites++;
                if (file.peek() == '\n' || file.peek() == EOF) break;
            }
        }


        else if (lineType == "Spline") {
            Splines s;
            int r, g, b;
            file >> s.n;

            if (s.n <= 0 || s.n > 1000) {
                MessageBox(NULL, L"Invalid number of spline points!", L"Error", MB_OK);
                return;
            }

            s.p.resize(s.n);
            for (int i = 0; i < s.n; i++) {
                file >> s.p[i].x >> s.p[i].y;
            }

            file >> s.c;

            file >> r >> g >> b;
            s.color = RGB(r, g, b);

            splines.push_back(s);
            coutSplines++;
        }



        else if (lineType == "AdvancedShapes") {
            AdvancedShape s;
            int numPoints, r, g, b;
            std::string type;
            while (file >> type >> numPoints) {
                s.type = type;
                s.points.resize(numPoints);
                for (int i = 0; i < numPoints; i++) {
                    file >> s.points[i].x >> s.points[i].y;
                }
                file >> r >> g >> b;
                s.color = RGB(r, g, b);
                advancedShapes.push_back(s);
                countAdvanced++;
                if (file.peek() == '\n' || file.peek() == EOF) break;
            }
        }

        if (lineType == "ClippingMethod") {
            int method;
            file >> method;
            currentClippingMethod = static_cast<ClippingMethod>(method);
        }
        else if (lineType == "ClippingRect") {
            file >> clippingRect.left >> clippingRect.top >> clippingRect.right >> clippingRect.bottom;
        }
        else if (lineType == "ClippingSquare") {
            file >> clippingSquare.left >> clippingSquare.top >> clippingSquare.right >> clippingSquare.bottom;
        }
    }
    file.close();
    std::cout << "Loaded " << countLines << " line(s), " << countCircles << " circle(s), " << countEllipse << " ellipse(s), "
        << countBeziers << " Bezier curve(s), " << countHermites << " Hermite curve(s), "
        << countAdvanced << " advanced shape(s) from shapes.txt\n";

    InvalidateRect(hwnd, NULL, TRUE);
}











void AddMenus(HWND hwnd) {
    HMENU hMenubar = CreateMenu();
    HMENU hFile = CreateMenu();
    HMENU hColor = CreateMenu();
    HMENU hPoint = CreateMenu();
    HMENU hLineAlgorithms = CreateMenu();
    HMENU hCircleAlgorithms = CreateMenu();
    HMENU hDrowSplines = CreateMenu();

    HMENU hEllipseAlgorithms = CreateMenu();

    HMENU hAdvancedShapes = CreateMenu();
    HMENU hQuarter = CreateMenu();
    HMENU hClipping = CreateMenu();

    // File menu
    AppendMenu(hFile, MF_STRING, ID_BACKGROUND_WHITE, L"Set Background White");
    AppendMenu(hFile, MF_STRING, ID_SCREEN_CLEAR, L"Clear Screen");
    AppendMenu(hFile, MF_STRING, ID_SAVE, L"Save");
    AppendMenu(hFile, MF_STRING, ID_LOAD, L"Load");
    AppendMenu(hFile, MF_SEPARATOR, 0, NULL);
    AppendMenu(hFile, MF_STRING, ID_FILE_EXIT, L"Exit");

    // Color menu
    AppendMenu(hColor, MF_STRING, ID_COLOR_RED, L"Red");
    AppendMenu(hColor, MF_STRING, ID_COLOR_GREEN, L"Green");
    AppendMenu(hColor, MF_STRING, ID_COLOR_BLUE, L"Blue");

    //point
    AppendMenu(hPoint, MF_STRING, ID_POINT, L"Point");
    AppendMenu(hPoint, MF_SEPARATOR, 0, NULL);

    // Line algorithms
    AppendMenu(hLineAlgorithms, MF_STRING, ID_LINE_BRESENHAM, L"Bresenham Line");
    AppendMenu(hLineAlgorithms, MF_STRING, ID_LINE_DDA, L"DDA Line");
    AppendMenu(hLineAlgorithms, MF_STRING, ID_LINE_PARAMETRIC, L"Parametric Line");
    AppendMenu(hLineAlgorithms, MF_SEPARATOR, 0, NULL);
    AppendMenu(hLineAlgorithms, MF_STRING, 0, L"Select to draw lines");

    // Circle algorithms
    AppendMenu(hCircleAlgorithms, MF_STRING, ID_CIRCLE_DIRECT, L"Direct Circle");
    AppendMenu(hCircleAlgorithms, MF_STRING, ID_CIRCLE_POLAR, L"Polar Circle2");
    AppendMenu(hCircleAlgorithms, MF_STRING, ID_CIRCLE_ITERATIVE_POLAR, L"Iterative Polar Circle");
    AppendMenu(hCircleAlgorithms, MF_STRING, ID_CIRCLE_MIDPOINT, L"Midpoint Circle");
    AppendMenu(hCircleAlgorithms, MF_STRING, ID_CIRCLE_MODIFIED_MIDPOINT, L"Modified Midpoint Circle");
    AppendMenu(hCircleAlgorithms, MF_STRING, ID_CIRCLE_FILL_LINES, L"Fill with Lines");
    AppendMenu(hCircleAlgorithms, MF_STRING, ID_CIRCLE_FILL_CIRCLES, L"Fill with Circles");
    AppendMenu(hCircleAlgorithms, MF_SEPARATOR, 0, NULL);
    AppendMenu(hCircleAlgorithms, MF_STRING, 0, L"Select to draw circles");
    AppendMenu(hDrowSplines, MF_STRING, ID_DROW_SPLINES, L"Drow Splines");



    //Ellipse allgoritms

    AppendMenu(hEllipseAlgorithms, MF_STRING, ID_ELLIPSE_DIRECT, L"Direct Ellipse");
    AppendMenu(hEllipseAlgorithms, MF_STRING, ID_ELLIPSE_POLAR, L"Polar Ellipse");
    AppendMenu(hEllipseAlgorithms, MF_STRING, ID_ELLIPSE_MIDPOINT, L"Midpoint Ellipse");







    // Quarter selection
    AppendMenu(hQuarter, MF_STRING, ID_QUARTER_1, L"Quarter 1 (Top-Right)");
    AppendMenu(hQuarter, MF_STRING, ID_QUARTER_2, L"Quarter 2 (Top-Left)");
    AppendMenu(hQuarter, MF_STRING, ID_QUARTER_3, L"Quarter 3 (Bottom-Left)");
    AppendMenu(hQuarter, MF_STRING, ID_QUARTER_4, L"Quarter 4 (Bottom-Right)");

    AppendMenu(hAdvancedShapes, MF_STRING, ID_BEZIER_CURVE, L"Bezier Curve");
    AppendMenu(hAdvancedShapes, MF_STRING, ID_HERMITE_CURVE, L"Hermite Curve");
    AppendMenu(hAdvancedShapes, MF_STRING, ID_CLIP_POLYGON, L"Polygon");
    AppendMenu(hAdvancedShapes, MF_STRING, ID_SPLINES_CURVE, L"Splines");
    AppendMenu(hAdvancedShapes, MF_STRING, ID_SQUARE_HERMITE, L"Square (Hermite Fill)");
    AppendMenu(hAdvancedShapes, MF_STRING, ID_RECTANGLE_BEZIER, L"Rectangle (Bezier Fill)");
    AppendMenu(hAdvancedShapes, MF_STRING, ID_POLYGON_CONVEX, L"Polygon (Convex Fill)");
    AppendMenu(hAdvancedShapes, MF_STRING, ID_POLYGON_NONCONVEX, L"Polygon (Non-Convex Fill)");
    AppendMenu(hAdvancedShapes, MF_STRING, ID_FLOOD_RECURSIVE, L"Flood Fill (Recursive)");
    AppendMenu(hAdvancedShapes, MF_STRING, ID_FLOOD_NON_RECURSIVE, L"Flood Fill (Non-Recursive)");
    AppendMenu(hAdvancedShapes, MF_STRING, ID_EMPTY_SQUARE, L"Empty Square");
    AppendMenu(hAdvancedShapes, MF_SEPARATOR, 0, NULL);
    AppendMenu(hAdvancedShapes, MF_STRING, 0, L"Select for advanced shapes");

    // Clipping submenu
    AppendMenu(hClipping, MF_STRING, ID_CLIP_RECTANGLE, L"Rectangle Clipping");
    AppendMenu(hClipping, MF_STRING, ID_CLIP_SQUARE, L"Square Clipping");
    AppendMenu(hClipping, MF_STRING, ID_CLIP_NONE, L"None Clipping");
    AppendMenu(hClipping, MF_SEPARATOR, 0, NULL);

    // Main menu
    AppendMenu(hMenubar, MF_POPUP, (UINT_PTR)hFile, L"File");
    AppendMenu(hMenubar, MF_POPUP, (UINT_PTR)hColor, L"Shape Color");
    AppendMenu(hMenubar, MF_POPUP, (UINT_PTR)hPoint, L"Point");
    AppendMenu(hMenubar, MF_POPUP, (UINT_PTR)hLineAlgorithms, L"Line Algorithms");
    AppendMenu(hMenubar, MF_POPUP, (UINT_PTR)hCircleAlgorithms, L"Circle Algorithms");
    AppendMenu(hMenubar, MF_POPUP, (UINT_PTR)hAdvancedShapes, L"Advanced Shapes");
    AppendMenu(hMenubar, MF_POPUP, (UINT_PTR)hQuarter, L"Quarter Selection");
    AppendMenu(hMenubar, MF_POPUP, (UINT_PTR)hClipping, L"Clipping");
    AppendMenu(hMenubar, MF_POPUP, (UINT_PTR)hEllipseAlgorithms, L"Ellipse");



    SetMenu(hwnd, hMenubar);
}














LRESULT CALLBACK WindowProcedure(HWND hwnd, UINT msg, WPARAM wp, LPARAM lp) {
    switch (msg) {
    case WM_CREATE:
        AddMenus(hwnd);
        break;

    case WM_COMMAND:
        switch (wp) {
        case ID_FILE_EXIT:
            PostQuitMessage(0);
            break;
        case ID_COLOR_RED:
            currentColor = RGB(255, 0, 0);
            break;
        case ID_COLOR_GREEN:
            currentColor = RGB(0, 255, 0);
            break;
        case ID_COLOR_BLUE:
            currentColor = RGB(0, 0, 255);
            break;
        case ID_BACKGROUND_WHITE:
            bgBrush = CreateSolidBrush(RGB(255, 255, 255));
            InvalidateRect(hwnd, NULL, TRUE);
            break;
        case ID_SCREEN_CLEAR:
            lines.clear();
            circles.clear();
            ellipses.clear();
            bezierCurves.clear();
            hermiteCurves.clear();
            advancedShapes.clear();
            tempPoints.clear();
            tempColors.clear();
            InvalidateRect(hwnd, NULL, TRUE);
            break;
        case ID_SAVE:
            SaveData();
            break;
        case ID_LOAD:
            LoadData(hwnd);
            break;
        case ID_POINT:
            currentShapeType = point;
            break;
        case ID_LINE_BRESENHAM:
            currentShapeType = LINE;
            currentLineAlgorithm = BRESENHAM;
            break;
        case ID_LINE_DDA:
            currentShapeType = LINE;
            currentLineAlgorithm = DDA;
            break;
        case ID_LINE_PARAMETRIC:
            currentShapeType = LINE;
            currentLineAlgorithm = PARAMETRIC;
            break;
        case ID_CIRCLE_DIRECT:
            currentShapeType = CIRCLE;
            currentCircleAlgorithm = DIRECT;
            break;
        case ID_CIRCLE_POLAR:
            currentShapeType = CIRCLE;
            currentCircleAlgorithm = POLAR;
            break;
        case ID_CIRCLE_ITERATIVE_POLAR:
            currentShapeType = CIRCLE;
            currentCircleAlgorithm = ITERATIVE_POLAR;
            break;
        case ID_CIRCLE_MIDPOINT:
            currentShapeType = CIRCLE;
            currentCircleAlgorithm = MIDPOINT;
            break;
        case ID_CIRCLE_MODIFIED_MIDPOINT:
            currentShapeType = CIRCLE;
            currentCircleAlgorithm = MODIFIED_MIDPOINT;
            break;
        case ID_CIRCLE_FILL_LINES:
            currentShapeType = CIRCLE;
            currentCircleAlgorithm = FILL_LINES;
            break;
        case ID_CIRCLE_FILL_CIRCLES:
            currentShapeType = CIRCLE;
            currentCircleAlgorithm = FILL_CIRCLES;
            break;

            //////////////////////////////////////////////

        case ID_ELLIPSE_DIRECT:
            currentShapeType = ELLIPSE;
            ellipseAlgorithm = DIRECTE;
            break;

        case ID_ELLIPSE_POLAR:
            currentShapeType = ELLIPSE;
            ellipseAlgorithm = POLARE;
            break;
        case ID_ELLIPSE_MIDPOINT:
            currentShapeType = ELLIPSE;
            ellipseAlgorithm = MIDPOINTE;
            break;


        case ID_CLIP_POLYGON:
            currentShapeType = POLYGON;
            break;












        case ID_SPLINES_CURVE:
            currentShapeType = SPLINES;
            ShowConsole();

            int numPoints;
            double tension;

            cout << "Enter number of points: ";
            cin >> numPoints;

            cout << "Enter tension value (e.g. 0.5): ";
            cin >> tension;

            //    global  static 
            splinesSize = numPoints;
            mytenstion = tension;

            cout << "You can now click " << splinesSize << " points in the window.\n";

            break;

        case ID_BEZIER_CURVE:
            currentShapeType = BEZIER;
            break;
        case ID_HERMITE_CURVE:
            currentShapeType = HERMITE;
            break;
        case ID_SQUARE_HERMITE:
            currentShapeType = SQUARE_HERMITE;
            break;
        case ID_RECTANGLE_BEZIER:
            currentShapeType = RECTANGLE_BEZIER;
            break;
        case ID_POLYGON_CONVEX:
            currentShapeType = POLYGON_CONVEX;
            break;
        case ID_POLYGON_NONCONVEX:
            currentShapeType = POLYGON_NONCONVEX;
            break;
        case ID_FLOOD_RECURSIVE:
            currentShapeType = FLOOD_RECURSIVE;
            break;
        case ID_FLOOD_NON_RECURSIVE:
            currentShapeType = FLOOD_NON_RECURSIVE;
            break;
        case ID_EMPTY_SQUARE:
            currentShapeType = EMPTY_SQUARE;
            break;
        case ID_QUARTER_1:
            currentQuarter = 1;
            break;
        case ID_QUARTER_2:
            currentQuarter = 2;
            break;
        case ID_QUARTER_3:
            currentQuarter = 3;
            break;
        case ID_QUARTER_4:
            currentQuarter = 4;
            break;
        case ID_CLIP_NONE:
            currentClippingMethod = None;
            clippingEnabled = false;
            clippingEnabledSquare = false;
            InvalidateRect(hwnd, NULL, TRUE);
            break;

        case ID_CLIP_RECTANGLE:
            currentClippingMethod = RECTANGLE;
            clippingEnabled = false;
            clippingEnabledSquare = false;
            pointCount = 0;
            InvalidateRect(hwnd, NULL, TRUE);
            break;

        case ID_CLIP_SQUARE:
            currentClippingMethod = SQUARE;
            clippingEnabledSquare = false;
            clippingEnabled = false;
            pointCount = 0;
            InvalidateRect(hwnd, NULL, TRUE);
            break;
        }
        break;









    case WM_LBUTTONDOWN: {
        POINT p = { LOWORD(lp), HIWORD(lp) };

        tempPoints.push_back(Point(p.x, p.y));
        tempColors.push_back(currentColor);

        if (firstClick) {
            tempPoint = p;
            firstClick = false;
            SetCapture(hwnd);
        }
        HDC hdc = GetDC(hwnd);
        

        if ((currentClippingMethod == RECTANGLE || currentClippingMethod == SQUARE) && pointCount <= 2) {
            if (pointCount > 2) {
                break;
            }

            points[pointCount++] = { p.x, p.y };


            if (currentClippingMethod == RECTANGLE) {
                if (pointCount == 2) {
                    clippingRect.left = min(points[0].x, points[1].x);
                    clippingRect.right = max(points[0].x, points[1].x);
                    clippingRect.top = min(points[0].y, points[1].y);
                    clippingRect.bottom = max(points[0].y, points[1].y);

                    clippingRectDrawn = true;
                    clippingEnabled = true;

                    tempPoints.clear();
                    tempColors.clear();
                    firstClick = true;
                    ReleaseCapture();

                    InvalidateRect(hwnd, NULL, TRUE);
                }
            }
            else if (currentClippingMethod == SQUARE) {
                if (pointCount == 2) {
                    int side = max(abs(points[1].x - points[0].x), abs(points[1].y - points[0].y));

                    clippingSquare.left = min(points[0].x, points[1].x);
                    clippingSquare.top = min(points[0].y, points[1].y);
                    clippingSquare.right = clippingSquare.left + side;
                    clippingSquare.bottom = clippingSquare.top + side;

                    clippingEnabledSquare = true;
                    clippingSquareDrawn = true;

                    tempPoints.clear();
                    tempColors.clear();
                    firstClick = true;
                    ReleaseCapture();

                    InvalidateRect(hwnd, NULL, TRUE);
                }
            }
        }


        if (currentShapeType == LINE && tempPoints.size() == 2) {
            Line line;
            line.x1 = tempPoints[0].x;
            line.y1 = tempPoints[0].y;
            line.x2 = tempPoints[1].x;
            line.y2 = tempPoints[1].y;
            line.color = currentColor;
            line.algorithm = currentLineAlgorithm;

            if (clippingEnabled || clippingEnabledSquare) {
                Point p1 = { line.x1, line.y1 };
                Point p2 = { line.x2, line.y2 };

                if (clippingEnabled) {
                    xmin = clippingRect.left;
                    xmax = clippingRect.right;
                    ymin = clippingRect.top;
                    ymax = clippingRect.bottom;
                }
                else if (clippingEnabledSquare) {
                    xmin = clippingSquare.left;
                    xmax = clippingSquare.right;
                    ymin = clippingSquare.top;
                    ymax = clippingSquare.bottom;
                }


                if (ClipLine(p1, p2)) {
                    line.x1 = p1.x;
                    line.y1 = p1.y;
                    line.x2 = p2.x;
                    line.y2 = p2.y;

                    lines.push_back(line);

                    switch (line.algorithm) {
                    case DDA:
                        DrawLineDDA(hdc, line.x1, line.y1, line.x2, line.y2, line.color);
                        break;
                    case BRESENHAM:
                        DrawLineBres(hdc, line.x1, line.y1, line.x2, line.y2, line.color);
                        break;
                    case PARAMETRIC:
                        ParametricLine(hdc, line.x1, line.y1, line.x2, line.y2, line.color);
                        break;
                    }
                }
            }
            else {
                lines.push_back(line);

                switch (line.algorithm) {
                case DDA:
                    DrawLineDDA(hdc, line.x1, line.y1, line.x2, line.y2, line.color);
                    break;
                case BRESENHAM:
                    DrawLineBres(hdc, line.x1, line.y1, line.x2, line.y2, line.color);
                    break;
                case PARAMETRIC:
                    ParametricLine(hdc, line.x1, line.y1, line.x2, line.y2, line.color);
                    break;
                }
            }

            tempPoints.clear();
            tempColors.clear();
            firstClick = true;
            ReleaseCapture();
        }
        if (currentShapeType == point) {
            pointsArray.push_back(Point(p.x, p.y));

            if (clippingEnabled || clippingEnabledSquare) {
                if (clippingEnabled) {
                    xmin = clippingRect.left;
                    xmax = clippingRect.right;
                    ymin = clippingRect.top;
                    ymax = clippingRect.bottom;
                }
                else if (clippingEnabledSquare) {
                    xmin = clippingSquare.left;
                    xmax = clippingSquare.right;
                    ymin = clippingSquare.top;
                    ymax = clippingSquare.bottom;
                }

                if (p.x >= xmin && p.x <= xmax && p.y >= ymin && p.y <= ymax) {
                    clippingPoint(hdc, p.x, p.y, currentColor);
                }
            }
            else {
                clippingPoint(hdc, p.x, p.y, currentColor);
            }

            tempPoints.clear();
            tempColors.clear();
            firstClick = true;
            ReleaseCapture();
            ReleaseDC(hwnd, hdc);
            return 0;
        }

        if (currentShapeType == POLYGON && tempPoints.size() == 4) {
            Polygonc p;
            p.p = tempPoints;

            if (clippingEnabled) {
                p.xl = clippingRect.left;
                p.xr = clippingRect.right;
                p.yt = clippingRect.top;
                p.yb = clippingRect.bottom;
            }
            else {
                //     
                RECT windowRect;
                GetClientRect(hwnd, &windowRect); // hwnd  handle 

                p.xl = windowRect.left;
                p.xr = windowRect.right;
                p.yt = windowRect.top;
                p.yb = windowRect.bottom;
            }

            p.color = currentColor;
            polygons.push_back(p);

            PolygonClip(hdc, p.p, p.xl, p.xr, p.yt, p.yb, p.color);

            tempPoints.clear();
            tempColors.clear();
            firstClick = true;
            ReleaseCapture();
        }







        if (currentShapeType == CIRCLE && tempPoints.size() == 2) {
            Circle c;
            c.xc = tempPoint.x;
            c.yc = tempPoint.y;
            c.R = (int)sqrt((p.x - tempPoint.x) * (p.x - tempPoint.x) + (p.y - tempPoint.y) * (p.y - tempPoint.y));
            c.color = currentColor;
            c.quarter = currentQuarter;
            c.algorithm = currentCircleAlgorithm;
            circles.push_back(c);
            switch (c.algorithm) {
            case DIRECT:
                CircleDirect(hdc, c.xc, c.yc, c.R, c.color);
                break;
            case POLAR:
                CirclePolar(hdc, c.xc, c.yc, c.R, c.color);
                break;
            case ITERATIVE_POLAR:
                CircleIterativePolar(hdc, c.xc, c.yc, c.R, c.color);
                break;
            case MIDPOINT:
                CircleMidpoint(hdc, c.xc, c.yc, c.R, c.color);
                break;
            case MODIFIED_MIDPOINT:
                CircleModifiedMidpoint(hdc, c.xc, c.yc, c.R, c.color);
                break;
            case FILL_LINES:
                FillCircleWithLines(hdc, c.xc, c.yc, c.R, c.quarter, c.color);
                CircleDirect(hdc, c.xc, c.yc, c.R, c.color);
                break;
            case FILL_CIRCLES:
                FillCircleWithCircles(hdc, c.xc, c.yc, c.R, c.quarter, c.color);
                CircleDirect(hdc, c.xc, c.yc, c.R, c.color);
                break;
            }
            tempPoints.clear();
            tempColors.clear();
            firstClick = true;
            ReleaseCapture();
        }


        if (currentShapeType == ELLIPSE && tempPoints.size() == 2) {
            Ellipsee e;
            e.xc = (tempPoints[0].x + tempPoints[1].x) / 2;
            e.yc = (tempPoints[0].y + tempPoints[1].y) / 2;
            e.a = abs(tempPoints[0].x - tempPoints[1].x) / 2;
            e.b = abs(tempPoints[0].y - tempPoints[1].y) / 2;
            e.color = currentColor;
            e.algorithm = ellipseAlgorithm;
            e.quarter = currentQuarter;
            ellipses.push_back(e);
            switch (e.algorithm) {
            case DIRECTE:
                ellipseDirect(hdc, e.xc, e.yc, e.a, e.b, e.color);
                break;
            case POLARE:
                ellipsePolar(hdc, e.xc, e.yc, e.a, e.b, e.color);
                break;

            case MIDPOINTE:
                MidpointEllipse(hdc, e.xc, e.yc, e.a, e.b, e.color);
                break;

            }
            tempPoints.clear();
            tempColors.clear();
            firstClick = true;
            ReleaseCapture();
        }







        else if (currentShapeType == SPLINES && tempPoints.size() == splinesSize) {
            Splines s;
            s.p = tempPoints;
            s.c = mytenstion;
            s.n = splinesSize;

            s.color = currentColor;
            splines.push_back(s);
            DrawCardinalSpline(hdc, s.p, s.n, s.c, s.color);


            tempPoints.clear();
            tempColors.clear();
            firstClick = true;
            ReleaseCapture();
        }





        else if (currentShapeType == BEZIER && tempPoints.size() == 4) {
            BezierCurve b;
            b.p0 = tempPoints[0];
            b.p1 = tempPoints[1];
            b.p2 = tempPoints[2];
            b.p3 = tempPoints[3];
            b.c0 = tempColors[0];
            b.c1 = tempColors[1];
            b.c2 = tempColors[2];
            b.c3 = tempColors[3];
            bezierCurves.push_back(b);
            DrawBezierCurve(hdc, b.p0, b.c0, b.p1, b.c1, b.p2, b.c2, b.p3, b.c3);
            tempPoints.clear();
            tempColors.clear();
            firstClick = true;
            ReleaseCapture();
        }
        else if (currentShapeType == HERMITE && tempPoints.size() == 4) {
            HermiteCurve h;
            h.p0 = tempPoints[0];
            h.p1 = tempPoints[1];
            h.t0 = Point(tempPoints[2].x - tempPoints[0].x, tempPoints[2].y - tempPoints[0].y);
            h.t1 = Point(tempPoints[3].x - tempPoints[1].x, tempPoints[3].y - tempPoints[1].y);
            h.color = currentColor;
            hermiteCurves.push_back(h);
            DrawHermiteCurve(hdc, h.p0, h.p1, h.t0, h.t1, h.color);
            tempPoints.clear();
            tempColors.clear();
            firstClick = true;
            ReleaseCapture();
        }
        else if (currentShapeType == SQUARE_HERMITE && tempPoints.size() == 2) {
            AdvancedShape s;
            s.type = "square_hermite";
            s.points = tempPoints;
            s.color = currentColor;
            advancedShapes.push_back(s);
            Point topLeft(std::min(tempPoints[0].x, tempPoints[1].x), std::min(tempPoints[0].y, tempPoints[1].y));
            int size = std::max(abs(tempPoints[1].x - tempPoints[0].x), abs(tempPoints[1].y - tempPoints[0].y));
            FillSquareWithHermiteCurve(hdc, topLeft, size, s.color);
            tempPoints.clear();
            tempColors.clear();
            firstClick = true;
            ReleaseCapture();
        }
        else if (currentShapeType == RECTANGLE_BEZIER && tempPoints.size() == 2) {
            AdvancedShape s;
            s.type = "rectangle_bezier";
            s.points = tempPoints;
            s.color = currentColor;
            advancedShapes.push_back(s);
            Point topLeft(std::min(tempPoints[0].x, tempPoints[1].x), std::min(tempPoints[0].y, tempPoints[1].y));
            Point bottomRight(std::max(tempPoints[0].x, tempPoints[1].x), std::max(tempPoints[0].y, tempPoints[1].y));
            FillRectangleWithBezierCurve(hdc, topLeft, bottomRight, currentColor);
            tempPoints.clear();
            tempColors.clear();
            firstClick = true;
            ReleaseCapture();
        }
        else if (currentShapeType == EMPTY_SQUARE && tempPoints.size() == 2) {
            AdvancedShape s;
            s.type = "empty_square";
            s.points = tempPoints;
            s.color = currentColor;
            advancedShapes.push_back(s);
            Point topLeft(std::min(tempPoints[0].x, tempPoints[1].x), std::min(tempPoints[0].y, tempPoints[1].y));
            int size = std::max(abs(tempPoints[1].x - tempPoints[0].x), abs(tempPoints[1].y - tempPoints[0].y));
            if (size <= 0) size = 1;
            DrawEmptySquare(hdc, topLeft, size, currentColor);
            tempPoints.clear();
            tempColors.clear();
            firstClick = true;
            ReleaseCapture();
        }
        else if ((currentShapeType == POLYGON_CONVEX || currentShapeType == POLYGON_NONCONVEX) && tempPoints.size() >= (currentShapeType == POLYGON_CONVEX ? 3 : 4)) {
            AdvancedShape s;
            s.type = currentShapeType == POLYGON_CONVEX ? "polygon_convex" : "polygon_nonconvex";
            s.points = tempPoints;
            s.color = currentColor;
            advancedShapes.push_back(s);
            POINT* pArray = new POINT[s.points.size()];
            for (size_t i = 0; i < s.points.size(); i++) {
                pArray[i].x = s.points[i].x;
                pArray[i].y = s.points[i].y;
            }

            if (currentShapeType == POLYGON_CONVEX) {
                ConvexFill(hdc, pArray, s.points.size(), s.color);
            }
            else {
                GeneralPolygonFill(hdc, pArray, s.points.size(), s.color);
            }
            tempPoints.clear();
            tempColors.clear();
            firstClick = true;
            ReleaseCapture();
        }
        else if ((currentShapeType == FLOOD_RECURSIVE || currentShapeType == FLOOD_NON_RECURSIVE) && tempPoints.size() == 1) {
            AdvancedShape* targetBoundaryShape = nullptr;
            Circle* targetBoundaryCircle = nullptr;
            COLORREF boundaryColor;
            bool foundValidBoundary = false;

            // search through circles
            for (int i = circles.size() - 1; i >= 0; i--) {
                Circle& circle = circles[i];

                // Check if the click point is inside this circle
                int dx = p.x - circle.xc;
                int dy = p.y - circle.yc;
                double distance = sqrt(dx * dx + dy * dy);

                if (distance <= circle.R) {
                    targetBoundaryCircle = &circle;
                    boundaryColor = circle.color;
                    foundValidBoundary = true;
                    break;
                }
            }

            if (!foundValidBoundary) {
                for (int i = advancedShapes.size() - 1; i >= 0; i--) {
                    if (advancedShapes[i].type == "empty_square") {
                        AdvancedShape& boundaryShape = advancedShapes[i];

                        Point topLeft(std::min(boundaryShape.points[0].x, boundaryShape.points[1].x),
                            std::min(boundaryShape.points[0].y, boundaryShape.points[1].y));
                        Point bottomRight(std::max(boundaryShape.points[0].x, boundaryShape.points[1].x),
                            std::max(boundaryShape.points[0].y, boundaryShape.points[1].y));

                        if (p.x >= topLeft.x && p.x <= bottomRight.x && p.y >= topLeft.y && p.y <= bottomRight.y) {
                            targetBoundaryShape = &boundaryShape;
                            boundaryColor = boundaryShape.color;
                            foundValidBoundary = true;
                            break;
                        }
                    }
                }
            }

            if (foundValidBoundary) {
                COLORREF initialColor = GetPixel(hdc, p.x, p.y);

                if (initialColor != boundaryColor) {
                    AdvancedShape s;
                    s.type = currentShapeType == FLOOD_RECURSIVE ? "flood_recursive" : "flood_nonrecursive";
                    s.points = { Point(p.x, p.y) };
                    s.color = currentColor;
                    advancedShapes.push_back(s);

                    if (currentShapeType == FLOOD_RECURSIVE) {
                        FloodFillRecursive(hdc, p.x, p.y, currentColor, boundaryColor);
                    }
                    else {
                        FloodFillNonRecursive(hdc, p.x, p.y, currentColor, boundaryColor);
                    }
                }
            }


            tempPoints.clear();
            tempColors.clear();
            firstClick = true;
            ReleaseCapture();



        }
        break;
    }

    case WM_LBUTTONUP: {
        break;
    }

    case WM_PAINT: {
        PAINTSTRUCT ps;
        HDC hdc = BeginPaint(hwnd, &ps);
        FillRect(hdc, &ps.rcPaint, bgBrush);
        DrawAllShapes(hdc);

        EndPaint(hwnd, &ps);
        break;
    }

    case WM_SETCURSOR: {
        SetCursor(LoadCursor(NULL, IDC_CROSS));
        return TRUE;
    }

    case WM_DESTROY:
        PostQuitMessage(0);
        break;

    default:
        return DefWindowProc(hwnd, msg, wp, lp);
    }
    return 0;
}

















int WINAPI WinMain(HINSTANCE hInst, HINSTANCE hPrevInst, LPSTR args, int ncmdshow) {
    AllocConsole();
    FILE* stream;
    freopen_s(&stream, "CONOUT$", "w", stdout);

    std::cout << "Drawing App Started. Console linked.\n";

    WNDCLASSW wc = { 0 };
    wc.hbrBackground = bgBrush;
    wc.hCursor = LoadCursor(NULL, IDC_CROSS); // Use cross cursor consistently
    wc.hInstance = hInst;
    wc.lpszClassName = L"DrawingAppClass";
    wc.lpfnWndProc = WindowProcedure;

    if (!RegisterClassW(&wc))
        return -1;

    CreateWindowW(L"DrawingAppClass", L"2D Drawing Program", WS_OVERLAPPEDWINDOW | WS_VISIBLE,
        100, 100, 800, 600, NULL, NULL, NULL, NULL);

    MSG msg = { 0 };
    while (GetMessage(&msg, NULL, 0, 0)) {
        TranslateMessage(&msg);
        DispatchMessage(&msg);
    }

    return 0;
}
